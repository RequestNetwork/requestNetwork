/* tslint:disable */
/* eslint-disable spellcheck/spell-checker */
/* Generated by ts-generator ver. 0.0.8 */

import { Contract, ContractTransaction, EventFilter, Signer } from 'ethers';
import { Listener, Provider } from 'ethers/providers';
import { BigNumber, BigNumberish, Interface } from 'ethers/utils';
import { TransactionOverrides, TypedEventDescription, TypedFunctionDescription } from '.';

interface ERC20ContractInterface extends Interface {
  functions: {
    name: TypedFunctionDescription<{ encode([]: []): string }>;

    approve: TypedFunctionDescription<{
      encode([_spender, _value]: [string, BigNumberish]): string;
    }>;

    totalSupply: TypedFunctionDescription<{ encode([]: []): string }>;

    transferFrom: TypedFunctionDescription<{
      encode([_from, _to, _value]: [string, string, BigNumberish]): string;
    }>;

    decimals: TypedFunctionDescription<{ encode([]: []): string }>;

    burn: TypedFunctionDescription<{
      encode([_value]: [BigNumberish]): string;
    }>;

    tokenSaleContract: TypedFunctionDescription<{ encode([]: []): string }>;

    decreaseApproval: TypedFunctionDescription<{
      encode([_spender, _subtractedValue]: [string, BigNumberish]): string;
    }>;

    earlyInvestorWallet: TypedFunctionDescription<{ encode([]: []): string }>;

    balanceOf: TypedFunctionDescription<{ encode([_owner]: [string]): string }>;

    burnFrom: TypedFunctionDescription<{
      encode([_from, _value]: [string, BigNumberish]): string;
    }>;

    owner: TypedFunctionDescription<{ encode([]: []): string }>;

    symbol: TypedFunctionDescription<{ encode([]: []): string }>;

    transfer: TypedFunctionDescription<{
      encode([_to, _value]: [string, BigNumberish]): string;
    }>;

    increaseApproval: TypedFunctionDescription<{
      encode([_spender, _addedValue]: [string, BigNumberish]): string;
    }>;

    emergencyERC20Drain: TypedFunctionDescription<{
      encode([token, amount]: [string, BigNumberish]): string;
    }>;

    allowance: TypedFunctionDescription<{
      encode([_owner, _spender]: [string, string]): string;
    }>;

    transferOwnership: TypedFunctionDescription<{
      encode([newOwner]: [string]): string;
    }>;

    transferableStartTime: TypedFunctionDescription<{ encode([]: []): string }>;
  };

  events: {
    Burn: TypedEventDescription<{
      encodeTopics([_burner, _value]: [string | null, null]): string[];
    }>;

    OwnershipTransferred: TypedEventDescription<{
      encodeTopics([previousOwner, newOwner]: [string | null, string | null]): string[];
    }>;

    Approval: TypedEventDescription<{
      encodeTopics([owner, spender, value]: [string | null, string | null, null]): string[];
    }>;

    Transfer: TypedEventDescription<{
      encodeTopics([from, to, value]: [string | null, string | null, null]): string[];
    }>;
  };
}

export abstract class ERC20Contract extends Contract {
  abstract connect(signerOrProvider: Signer | Provider | string): ERC20Contract;
  abstract attach(addressOrName: string): ERC20Contract;
  abstract deployed(): Promise<ERC20Contract>;

  abstract on(event: EventFilter | string, listener: Listener): ERC20Contract;
  abstract once(event: EventFilter | string, listener: Listener): ERC20Contract;
  abstract addListener(eventName: EventFilter | string, listener: Listener): ERC20Contract;
  abstract removeAllListeners(eventName: EventFilter | string): ERC20Contract;
  abstract removeListener(eventName: any, listener: Listener): ERC20Contract;

  abstract interface: ERC20ContractInterface;

  abstract functions: {
    name(): Promise<string>;

    approve(
      _spender: string,
      _value: BigNumberish,
      overrides?: TransactionOverrides,
    ): Promise<ContractTransaction>;

    totalSupply(): Promise<BigNumber>;

    transferFrom(
      _from: string,
      _to: string,
      _value: BigNumberish,
      overrides?: TransactionOverrides,
    ): Promise<ContractTransaction>;

    decimals(): Promise<number>;

    burn(_value: BigNumberish, overrides?: TransactionOverrides): Promise<ContractTransaction>;

    tokenSaleContract(): Promise<string>;

    decreaseApproval(
      _spender: string,
      _subtractedValue: BigNumberish,
      overrides?: TransactionOverrides,
    ): Promise<ContractTransaction>;

    earlyInvestorWallet(): Promise<string>;

    balanceOf(_owner: string): Promise<BigNumber>;

    burnFrom(
      _from: string,
      _value: BigNumberish,
      overrides?: TransactionOverrides,
    ): Promise<ContractTransaction>;

    owner(): Promise<string>;

    symbol(): Promise<string>;

    transfer(
      _to: string,
      _value: BigNumberish,
      overrides?: TransactionOverrides,
    ): Promise<ContractTransaction>;

    increaseApproval(
      _spender: string,
      _addedValue: BigNumberish,
      overrides?: TransactionOverrides,
    ): Promise<ContractTransaction>;

    emergencyERC20Drain(
      token: string,
      amount: BigNumberish,
      overrides?: TransactionOverrides,
    ): Promise<ContractTransaction>;

    allowance(_owner: string, _spender: string): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: TransactionOverrides,
    ): Promise<ContractTransaction>;

    transferableStartTime(): Promise<BigNumber>;
  };

  abstract name(): Promise<string>;

  abstract approve(
    _spender: string,
    _value: BigNumberish,
    overrides?: TransactionOverrides,
  ): Promise<ContractTransaction>;

  abstract totalSupply(): Promise<BigNumber>;

  abstract transferFrom(
    _from: string,
    _to: string,
    _value: BigNumberish,
    overrides?: TransactionOverrides,
  ): Promise<ContractTransaction>;

  abstract decimals(): Promise<number>;

  abstract burn(
    _value: BigNumberish,
    overrides?: TransactionOverrides,
  ): Promise<ContractTransaction>;

  abstract tokenSaleContract(): Promise<string>;

  abstract decreaseApproval(
    _spender: string,
    _subtractedValue: BigNumberish,
    overrides?: TransactionOverrides,
  ): Promise<ContractTransaction>;

  abstract earlyInvestorWallet(): Promise<string>;

  abstract balanceOf(_owner: string): Promise<BigNumber>;

  abstract burnFrom(
    _from: string,
    _value: BigNumberish,
    overrides?: TransactionOverrides,
  ): Promise<ContractTransaction>;

  abstract owner(): Promise<string>;

  abstract symbol(): Promise<string>;

  abstract transfer(
    _to: string,
    _value: BigNumberish,
    overrides?: TransactionOverrides,
  ): Promise<ContractTransaction>;

  abstract increaseApproval(
    _spender: string,
    _addedValue: BigNumberish,
    overrides?: TransactionOverrides,
  ): Promise<ContractTransaction>;

  abstract emergencyERC20Drain(
    token: string,
    amount: BigNumberish,
    overrides?: TransactionOverrides,
  ): Promise<ContractTransaction>;

  abstract allowance(_owner: string, _spender: string): Promise<BigNumber>;

  abstract transferOwnership(
    newOwner: string,
    overrides?: TransactionOverrides,
  ): Promise<ContractTransaction>;

  abstract transferableStartTime(): Promise<BigNumber>;

  abstract filters: {
    Burn(_burner: string | null, _value: null): EventFilter;

    OwnershipTransferred(previousOwner: string | null, newOwner: string | null): EventFilter;

    Approval(owner: string | null, spender: string | null, value: null): EventFilter;

    Transfer(from: string | null, to: string | null, value: null): EventFilter;
  };

  abstract estimate: {
    name(): Promise<BigNumber>;

    approve(_spender: string, _value: BigNumberish): Promise<BigNumber>;

    totalSupply(): Promise<BigNumber>;

    transferFrom(_from: string, _to: string, _value: BigNumberish): Promise<BigNumber>;

    decimals(): Promise<BigNumber>;

    burn(_value: BigNumberish): Promise<BigNumber>;

    tokenSaleContract(): Promise<BigNumber>;

    decreaseApproval(_spender: string, _subtractedValue: BigNumberish): Promise<BigNumber>;

    earlyInvestorWallet(): Promise<BigNumber>;

    balanceOf(_owner: string): Promise<BigNumber>;

    burnFrom(_from: string, _value: BigNumberish): Promise<BigNumber>;

    owner(): Promise<BigNumber>;

    symbol(): Promise<BigNumber>;

    transfer(_to: string, _value: BigNumberish): Promise<BigNumber>;

    increaseApproval(_spender: string, _addedValue: BigNumberish): Promise<BigNumber>;

    emergencyERC20Drain(token: string, amount: BigNumberish): Promise<BigNumber>;

    allowance(_owner: string, _spender: string): Promise<BigNumber>;

    transferOwnership(newOwner: string): Promise<BigNumber>;

    transferableStartTime(): Promise<BigNumber>;
  };
}
